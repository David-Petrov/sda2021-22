# Task 3. Няма К-то-мато (Medium)

[HackerRank link](<https://www.hackerrank.com/contests/sda-hw-6-2021/challenges/--108>)

## Statement:

Имате дадено двоично дърво за търсене (BST) с $N$ елемента и цяло число $K$. Изтрийте $K$-тия най-голям елемент и изведете стойностите на дървото подредени по нива от дясно на ляво (level order). Ако изтритият елемент има два наследника, елементът, заемащ мястото на изтрития, е най-лявото листо в дясното му поддърво.

_Иска се да изведете първо корена после върховете на ниво 1 от ляво на дясно и после върховете от ниво 2 от ляво на дясно и т.н._

**Input Format**

На първия ред от стандартният вход се въвеждат $N$ и $K$.

Следват $N$ на брой цели числа $a_0,\dots,a_{N-1}$ - елементите, които трябва да се добавят в дървото. Родителят на елементa $a_i$ е $a_{(i-1)/2}$.

_Върхът, който съдържа стойността на индекс $i$ в масива, е родител на върховете със стойности съответно на индекси $2i + 1$ и $2i+2$._

**Constraints**

$0\le N\le10^5$

$0\le a_i\le 10^5$

**Output format**

Изведете $N-1$ цели числа - останалите елементи в дървото, след премахването на $K$-тия най-голям.

---

**Sample Input 0**

```
5 1
4 2 7 1 3
```

**Sample Output 0**

```
4 2 1 3
```

**Explanation 0**

```
            4
           / \
          2   7
         / \
        1   3

```

1-вият най-голям елемент е 7, следователно след изтриването му дървото изглежда така:

```
            4
           / 
          2   
         / \
        1   3
```

---

**Sample Input 1**

```
6 5
10 8 12 7 9 11
```

**Sample Output 1**

```
10 9 12 7 11
```

**Explanation 1**

```
            10
           /  \
          8    12
         / \   /
        7   9 11

```

5-тият най-голям елемент е 8, следователно след изтриването му дървото изглежда така:

```
            10
           /  \
          9    12
         /    /
        7    11
```